{"idx": 0, "code": "public Rule XXXXX(final int nrCycles) {\n    Preconditions.checkArgument(nrCycles >= 0, \"illegal repetition number specified (\" + nrCycles + \"), must be 0 or greater\");\n    return range(Range.atMost(nrCycles));\n}", "Function Name 1": "max", "Function Name 2": "cycle", "Function Name 3": "cyclic", "Function Name 4": "createrulewithrepetition"}
{"idx": 1, "code": "public static Characters XXXXX(final char... chars) {\n    final int length = chars.length;\n    if (length == 0) {\n        return ALL;\n    }\n\n    final char[] array = Arrays.copyOf(chars, length);\n    Arrays.sort(array);\n    return new Characters(true, array);\n}", "Function Name 1": "allBut", "Function Name 2": "of", "Function Name 3": "of", "Function Name 4": "characters"}
{"idx": 2, "code": "private boolean XXXXX(RequestContext requestContext, ConfigValue<Long> timeout) {\n    // return false if no timeout configured or per-request timeout already specified in request context\n    return timeout.getValue() != null && timeout.getValue() > 0 && !hasRequestContextTimeout(requestContext);\n}", "Function Name 1": "needApplyTaskTimeout", "Function Name 2": "checktimeout", "Function Name 3": "hastimeout", "Function Name 4": "istimeoutsetinrequestcontext"}
{"idx": 3, "code": "public Jdbi3 XXXXX(Consumer<Jdbi> configurer) {\n    return doWith((jdbi, conf) -> configurer.accept(jdbi));\n}", "Function Name 1": "doWith", "Function Name 2": "configure", "Function Name 3": "configure", "Function Name 4": "configurejdbi"}
{"idx": 4, "code": "public boolean XXXXX(final URI uri) {\n    for (final MigrationLoader loader : loaders) {\n        if (loader.accept(uri)) {\n            return true;\n        }\n    }\n    return false;\n}", "Function Name 1": "accept", "Function Name 2": "load", "Function Name 3": "canload", "Function Name 4": "ismigrationloaderexistsforuri"}
{"idx": 5, "code": "public void XXXXX(String name, Command command) {\n    Preconditions.checkArgument(name != null && !name.isEmpty(), \"Parameter 'name' must not be [\" + name + \"]\");\n    Preconditions.checkArgument(command != null, \"Parameter 'command' must not be [\" + command + \"]\");\n    commands.put(name, command);\n}", "Function Name 1": "register", "Function Name 2": "addcommand", "Function Name 3": "addcommand", "Function Name 4": "addcommandtomap"}
{"idx": 6, "code": "private void XXXXX(Collection<FileDescriptor> target, Map<String, FileDescriptor> after) {\n    Map<String, FileDescriptor> before = getCache(target);\n    Map<String, FileDescriptor> all = new HashMap<>();\n    all.putAll(before);\n    all.putAll(after);\n\n    for (Map.Entry<String, FileDescriptor> entry : all.entrySet()) {\n        String key = entry.getKey();\n        FileDescriptor fileDescriptor = entry.getValue();\n        boolean hasBefore = before.containsKey(key);\n        boolean hasAfter = after.containsKey(key);\n\n        if (hasBefore && !hasAfter) {\n            target.remove(fileDescriptor);\n        } else if (!hasBefore && hasAfter) {\n            target.add(fileDescriptor);\n        }\n    }\n}", "Function Name 1": "sync", "Function Name 2": "updatecache", "Function Name 3": "mergecache", "Function Name 4": "updatetargetcollection"}
{"idx": 7, "code": "public static void XXXXX(final String name, final boolean condition, final SingleResultCallback<?> callback) {\n    if (!condition) {\n        IllegalStateException exception = new IllegalStateException(\"state should be: \" + name);\n        callback.onResult(null, exception);\n        throw exception;\n    }\n}", "Function Name 1": "isTrue", "Function Name 2": "checkstate", "Function Name 3": "checkstate", "Function Name 4": "validateconditionandcallback"}
{"idx": 8, "code": "@SafeVarargs\npublic static <T> T[]XXXXX(final T[] array1, final T... array2) {\n    if (isEmpty(array1) && isEmpty(array2)) {\n        return null;\n    }\n\n    if (isEmpty(array1)) {\n        return array2;\n    }\n\n    if (isEmpty(array2)) {\n        return array1;\n    }\n\n    final Class<?> type1 = array1.getClass().getComponentType();\n\n    @SuppressWarnings(\"unchecked\") // OK, because array is of type T\n    final T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n\n    int index = 0;\n    for (T item : array1) {\n        joinedArray[index++] = item;\n    }\n\n    for (T item : array2) {\n        joinedArray[index++] = item;\n    }\n\n    return joinedArray;\n}", "Function Name 1": "join", "Function Name 2": "concat", "Function Name 3": "concat", "Function Name 4": "mergearrays"}
{"idx": 9, "code": "private static String XXXXX(String service, String base) {\n    if (base == null) {\n        base = DEFAULT_DNS;\n    }\n    return String.format(DNS_NAME_FORMAT, service, base);\n}", "Function Name 1": "getDNS", "Function Name 2": "naturalname", "Function Name 3": "getdnsname", "Function Name 4": "generatednsname"}
{"idx": 10, "code": "public StringClauses XXXXX(String existingKey, String newKey, String newValue) throws IllegalArgumentException {\n    return insertBeforeImpl(existingKey, newKey, newValue);\n}", "Function Name 1": "insertBefore", "Function Name 2": "replace", "Function Name 3": "addclause", "Function Name 4": "updatekeyvalue"}
{"idx": 11, "code": "public URI XXXXX(final URI uri) throws URISyntaxException, StorageException {\n    final String origRawQuery = uri.getRawQuery();\n    final String rawFragment = uri.getRawFragment();\n    final String uriString = uri.resolve(uri).toASCIIString();\n    final HashMap<String, String[]> origQueryMap = PathUtility.parseQueryString(origRawQuery);\n\n    // Try/Insert original queries to map\n    for (final Entry<String, String[]> entry : origQueryMap.entrySet()) {\n        for (final String val : entry.getValue()) {\n            this.insertKeyValue(entry.getKey(), val);\n        }\n    }\n\n    final StringBuilder retBuilder = new StringBuilder();\n\n    // has a fragment\n    if (Utility.isNullOrEmpty(origRawQuery) && !Utility.isNullOrEmpty(rawFragment)) {\n        final int bangDex = uriString.indexOf(' ');\n        retBuilder.append(uriString.substring(0, bangDex));\n    } else if (!Utility.isNullOrEmpty(origRawQuery)) {\n        // has a query\n        final int queryDex = uriString.indexOf(' ');\n        retBuilder.append(uriString.substring(0, queryDex));\n    } else {\n        // no fragment or query\n        retBuilder.append(uriString);\n        if (uri.getRawPath().length() <= 0) {\n            retBuilder.append(\"/\");\n        }\n    }\n\n    final String finalQuery = this.toString();\n\n    if (finalQuery.length() > 0) {\n        retBuilder.append(\"?\");\n        retBuilder.append(finalQuery);\n    }\n\n    if (!Utility.isNullOrEmpty(rawFragment)) {\n        retBuilder.append(\"#\");\n        retBuilder.append(rawFragment);\n    }\n\n    return new URI(retBuilder.toString());\n}", "Function Name 1": "addToURI", "Function Name 2": "convert", "Function Name 3": "rewrite", "Function Name 4": "resolveandinsertqueries"}
{"idx": 12, "code": "public String XXXXX() {\n    return new StringBuilder()\n            .append(this.minX).append(\" \")\n            .append(this.minY).append(\" \")\n            .append(this.width).append(\" \")\n            .append(this.height)\n            .toString();\n}", "Function Name 1": "valueStr", "Function Name 2": "tomap", "Function Name 3": "getformattedrect", "Function Name 4": "getboundingboxstring"}
{"idx": 13, "code": "public void XXXXX(String name) {\n    Preconditions.checkArgument(name != null && !name.isEmpty(), \"Parameter 'name' must not be [\" + name + \"]\");\n    commands.remove(name);\n}", "Function Name 1": "unregister", "Function Name 2": "removecommand", "Function Name 3": "removecommand", "Function Name 4": "removecommandbyname"}
{"idx": 14, "code": "public String XXXXX() {\n    flattenAsMap();\n    if (source.isObject() || isObjectifiableArray()) {\n        return flattenedMap.toString(printMode);\n    } else {\n        return javaObj2Json(flattenedMap.get(ROOT));\n    }\n}", "Function Name 1": "flatten", "Function Name 2": "serialize", "Function Name 3": "serialize", "Function Name 4": "tojsontostring"}
{"idx": 15, "code": "@DoesServiceRequest\npublic final String XXXXX(\n    final URI source,\n    final AccessCondition sourceAccessCondition,\n    final AccessCondition destinationAccessCondition,\n    FileRequestOptions options,\n    OperationContext opContext\n) throws StorageException, URISyntaxException {\n    if (opContext == null) {\n        opContext = new OperationContext();\n    }\n\n    this.getShare().assertNoSnapshot();\n    opContext.initialize();\n    options = FileRequestOptions.populateAndApplyDefaults(options, this.fileServiceClient);\n\n    return ExecutionEngine.executeWithRetry(\n        this.fileServiceClient,\n        this,\n        this.startCopyImpl(source, sourceAccessCondition, destinationAccessCondition, options),\n        options.getRetryPolicyFactory(),\n        opContext\n    );\n}", "Function Name 1": "startCopy", "Function Name 2": "getfiles", "Function Name 3": "move", "Function Name 4": "executeservicerequest"}
{"idx": 16, "code": "@Override\npublic void XXXXX(String tagName, int value, Map attributes) {\n    addTag(tagName, String.valueOf(value), attributes);\n}", "Function Name 1": "addTag", "Function Name 2": "starttag", "Function Name 3": "startelement", "Function Name 4": "processtagwithattributes"}
{"idx": 17, "code": "private Object XXXXX() {\n    return dataPosition < dataSize && data[dataPosition] != null ? data[dataPosition].value : null;\n}", "Function Name 1": "peek", "Function Name 2": "getvalue", "Function Name 3": "getdatavalue", "Function Name 4": "getdatavalue"}
{"idx": 18, "code": "@DontLabel\npublic Rule XXXXX(final String characters) {\n    Objects.requireNonNull(characters);\n    return anyOf(characters.toCharArray());\n}", "Function Name 1": "anyOf", "Function Name 2": "withcharacters", "Function Name 3": "startwith", "Function Name 4": "wrapcharacterstoarray"}
{"idx": 19, "code": "public boolean XXXXX() {\n    Object okValue = get(\"ok\");\n\n    if (okValue instanceof Boolean) {\n        return (Boolean) okValue;\n    } else if (okValue instanceof Number) {\n        return ((Number) okValue).intValue() == 1;\n    } else {\n        return false;\n    }\n}", "Function Name 1": "ok", "Function Name 2": "query", "Function Name 3": "istrue", "Function Name 4": "checkiftrue"}
{"idx": 20, "code": "public static List<String> XXXXX(String text) {\n    List<String> list = new ArrayList<>();\n\n    if (StringUtils.isNullOrEmptyTrimmed(text)) {\n        return list;\n    }\n\n    for (int i = 0; i < text.length(); i++) {\n        list.add(Character.toString(text.charAt(i)));\n    }\n\n    return list;\n}", "Function Name 1": "asListOfChars", "Function Name 2": "tolist", "Function Name 3": "tokenizetos", "Function Name 4": "convertstringtolist"}
{"idx": 21, "code": "public void XXXXX() {\n    repl.set(true);\n    String line = null;\n\n    while (repl.get() && ((line = console.readLine()) != null)) {\n        exec(line);\n    }\n}", "Function Name 1": "start", "Function Name 2": "run", "Function Name 3": "run", "Function Name 4": "runrepl"}
{"idx": 22, "code": "URI XXXXX() {\n    StringBuilder builder = new StringBuilder();\n\n    if (defined(this.scheme)) {\n        builder.append(this.scheme);\n        builder.append(\":\");\n    }\n\n    if (defined(this.authority)) {\n        builder.append(\"//\");\n        builder.append(this.authority);\n    }\n\n    if (defined(this.path)) {\n        builder.append(this.path);\n    }\n\n    if (defined(this.query)) {\n        builder.append(\"?\");\n        builder.append(this.query);\n    }\n\n    if (defined(this.fragment)) {\n        builder.append(\"#\");\n        builder.append(this.fragment);\n    }\n\n    String rawURI = builder.toString();\n    return URI.create(rawURI);\n}", "Function Name 1": "toURI", "Function Name 2": "touri", "Function Name 3": "tour", "Function Name 4": "generateuri"}
{"idx": 23, "code": "public static String XXXXX(String key, String tag) {\n    return new StringBuilder(key)\n            .append(SIZE_SP)\n            .append(tag)\n            .toString();\n}", "Function Name 1": "joinSizeTagToKey", "Function Name 2": "createsession", "Function Name 3": "sizekeywith", "Function Name 4": "buildkeywithtag"}
{"idx": 24, "code": "public Thl XXXXX(final Consumer<TemplateEngine> callback) {\n    requireNonNull(callback, \"Callback required.\");\n    return doWith((e, c) -> callback.accept(e));\n}", "Function Name 1": "doWith", "Function Name 2": "before", "Function Name 3": "onsuccess", "Function Name 4": "callbackwrapper"}
